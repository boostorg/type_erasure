[library Boost.TypeErasure
    [quickbook 1.5]
    [authors [Watanabe, Steven]]
    [copyright 2011 Steven Watanabe]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
    [purpose Runtime polymorphism based on concepts]
]

[def __any [classref boost::type_erasure::any any]]
[def __any_cast [funcref boost::type_erasure::any_cast any_cast]]
[def __tuple [classref boost::type_erasure::tuple tuple]]
[def __rebind_any [classref boost::type_erasure::rebind_any rebind_any]]
[def __derived [classref boost::type_erasure::derived derived]]
[def __concept_interface [classref boost::type_erasure::concept_interface concept_interface]]
[def __constructible [classref boost::type_erasure::constructible constructible]]
[def __destructible [classref boost::type_erasure::destructible destructible]]
[def __copy_constructible [classref boost::type_erasure::copy_constructible copy_constructible]]
[def __typeid_ [classref boost::type_erasure::typeid_ typeid_]]
[def __relaxed_match [classref boost::type_erasure::relaxed_match relaxed_match]]
[def __binding [classref boost::type_erasure::binding binding]]
[def __static_binding [classref boost::type_erasure::static_binding static_binding]]
[def __placeholder [classref boost::type_erasure::placeholder placeholder]]
[def __call [funcref boost::type_erasure::call call]]
[def __deduced [classref boost::type_erasure::deduced deduced]]

[def __addable [classref boost::type_erasure::addable addable]]
[def __subtractable [classref boost::type_erasure::subtractable subtractable]]
[def __multipliable [classref boost::type_erasure::multipliable multipliable]]
[def __dividable [classref boost::type_erasure::dividable dividable]]
[def __modable [classref boost::type_erasure::modable modable]]
[def __bitandable [classref boost::type_erasure::bitandable bitandable]]
[def __bitorable [classref boost::type_erasure::bitorable bitorable]]
[def __bitxorable [classref boost::type_erasure::bitxorable bitxorable]]
[def __left_shiftable [classref boost::type_erasure::left_shiftable left_shiftable]]
[def __right_shiftable [classref boost::type_erasure::right_shiftable right_shiftable]]
[def __add_assignable [classref boost::type_erasure::add_assignable add_assignable]]
[def __subtract_assignable [classref boost::type_erasure::subtract_assignable subtract_assignable]]
[def __multiply_assignable [classref boost::type_erasure::multiply_assignable multiply_assignable]]
[def __divide_assignable [classref boost::type_erasure::divide_assignable divide_assignable]]
[def __mod_assignable [classref boost::type_erasure::mod_assignable mod_assignable]]
[def __bitand_assignable [classref boost::type_erasure::bitand_assignable bitand_assignable]]
[def __bitor_assignable [classref boost::type_erasure::bitor_assignable bitor_assignable]]
[def __bitxor_assignable [classref boost::type_erasure::bitxor_assignable bitxor_assignable]]
[def __left_shift_assignable [classref boost::type_erasure::left_shift_assignable left_shift_assignable]]
[def __right_shift_assignable [classref boost::type_erasure::right_shift_assignable right_shift_assignable]]
[def __incrementable [classref boost::type_erasure::incrementable incrementable]]
[def __decrementable [classref boost::type_erasure::decrementable decrementable]]
[def __negatable [classref boost::type_erasure::negatable negatable]]
[def __complementable [classref boost::type_erasure::complementable complementable]]
[def __dereferenceable [classref boost::type_erasure::dereferenceable dereferenceable]]
[def __callable [classref boost::type_erasure::callable callable]]
[def __subscriptable [classref boost::type_erasure::subscriptable subscriptable]]
[def __equality_comparable [classref boost::type_erasure::equality_comparable equality_comparable]]
[def __less_than_comparable [classref boost::type_erasure::less_than_comparable less_than_comparable]]
[def __ostreamable [classref boost::type_erasure::ostreamable ostreamable]]
[def __istreamable [classref boost::type_erasure::istreamable istreamable]]
[def __iterator [classref boost::type_erasure::iterator iterator]]
[def __forward_iterator [classref boost::type_erasure::forward_iterator forward_iterator]]
[def __bidirectional_iterator [classref boost::type_erasure::bidirectional_iterator bidirectional_iterator]]
[def __random_access_iterator [classref boost::type_erasure::random_access_iterator random_access_iterator]]
[def __same_type [classref boost::type_erasure::same_type same_type]]


[section:introduction Introduction]

C++ provides runtime polymorphism through virtual
functions.  They are a very useful feature, but
they do have some limitations.

* They are intrusive.  In generic programming, we can
  design an interface which allows third-party types
  to be adapted to it.
* They require dynamic memory management.  Of course,
  most of the problems can be avoided by using an
  appropriate smart pointer type. Even so, it still
  acts like a pointer rather than a value.
* Virtual functions' ability to apply multiple
  independent concepts to a single object is limited.

The Boost.TypeErasure library solves these problems
allowing us to mirror static generic programming
at runtime.

[note TypeErasure is not an official Boost library.]

[endsect]

[section:reading How to read this documentation]

To avoid excessive verbosity, all the examples
assume that a few using directives are in place.

    namespace mpl = boost::mpl;
    using namespace boost::type_erasure;

[endsect]

[section:basic Basic Usage]
[import ../example/basic.cpp]
[basic]
[endsect]

[section:multi Functions with Multiple Arguments]
[import ../example/multi.cpp]
[multi]
[endsect]

[section:references Using References]
[import ../example/references.cpp]
[references]
[endsect]

[section:construction Construction]
[import ../example/construction.cpp]
[construction]
[endsect]

[section:concept Concepts in Depth]

[section:custom Defining Custom Concepts]
[import ../example/custom.cpp]
[custom]
[endsect]

[section:compose Composing Concepts]
[import ../example/compose.cpp]
[compose]
[endsect]

[section:concept_map Concept Maps]
[import ../example/concept_map.cpp]
[concept_map]
[endsect]

[section:overload Overloading]
[import ../example/overload.cpp]
[overload]
[endsect]

[section:overload Associated Types]
[import ../example/associated.cpp]
[associated]
[endsect]

[endsect]

[section:examples Examples]

[section:print_sequence A polymorphic range formatter]
[import ../example/print_sequence.cpp]
[print_sequence]
[endsect]

[endsect]

[section:conceptdef Concept Definitions]

A placeholder is any type that inherits
publicly from __placeholder.

There are three kinds of concepts.

# The library defines a number of [link boost_typeerasure.predef predefined concepts].
# Any MPL Forward Sequence whose elements are
  concepts is also a concept.
# Users can define their own primitive concepts.

Each primitive concept defines a single operation.
A primitive concept must be a specialization of a
class template, with a static member function
called apply.

The template parameters of the concept
may involve placeholders.  The following are
considered.

* Each template argument may be a cv and/or reference
  qualified placeholder type.
* If a template argument is a function type, its
  arguments and return type may be cv/reference
  qualified placeholders.

Any other placeholders are ignored.

When a concept is instantiated with a specific
set of type bindings, each placeholder is bound
to a cv-unqualified non-reference type.  After
replacing each placeholder in the template argument
list with the type that it binds to, the following
must hold.

* The number of arguments of apply in the
  bound concept must be the same as the number
  of arguments in the unbound concept.
* The arguments and return type of apply in the
  bound concept can be derived from the corresponding
  arguments and the return type in the unbound concept
  as follows: If the argument in the unbound concept is a
  placeholder with optional cv and reference
  qualifiers, then the argument in the bound
  concept can be found by replacing the placeholder.
  Otherwise, the argument in the unbound concept
  must be the same as the argument in the bound concept.

[endsect]

[section:reserved Reserved Identifiers]

The library reserves all names begining with
`_boost_type_erasure` for use as members.  No
class shall contain such a member except
those defined by the library.

The library reserves all identifiers begining
with `BOOST_TYPE_ERASURE` for any use.

FIXME: this is too broad.
The library reserves all identifiers that
are either a single upper case letter,
a single upper case letter followed by
a sequence of digits, in CamelCase, or
underscore_separated for use in namespace
`boost::type_erasure`. Such identifiers may
not be defined as macros.  (Macros defined
in system headers that I know about are
excepted for the sake of pragmatism.).

[endsect]

[section:predef Predefined Concepts]

In the following tables, `T` and `U` are the types that the operation
applies to, `R` is the result type.  `T` always defaults
to `_self` to match the default behavior of any.  These
concepts assume normal semantics.  Thus, comparison
operators always return bool, and references will be
added to the arguments and results as appropriate.

[table:special Special Members
    [[concept][notes]]
    [[__constructible`<Sig>`][-]]
    [[__copy_constructible`<T>`][-]]
    [[__destructible`<T>`][-]]
    [[__typeid_`<T>`][-]]
]
[table:unary Unary Operators
    [[operator][concept][notes]]
    [[`operator++`][__incrementable`<T>`][There is no separate post-increment]]
    [[`operator--`][__decrementable`<T>`][There is no separate post-decrement]]
    [[`operator*`][__dereferenceable`<R, T>`][`R` should usually be a reference]]
    [[`operator~`][__complementable`<T, R = T>`][-]]
    [[`operator-`][__negatable`<T, R = T>`][-]]
]

[table:binary Binary Operators
    [[operator][concept][notes]]
    [[`operator+`][__addable`<T, U = T, R = T>`][-]]
    [[`operator-`][__subtractable`<T, U = T, R = T>`][-]]
    [[`operator*`][__multipliable`<T, U = T, R = T>`][-]]
    [[`operator/`][__dividable`<T, U = T, R = T>`][-]]
    [[`operator%`][__modable`<T, U = T, R = T>`][-]]
    [[`operator&`][__bitandable`<T, U = T, R = T>`][-]]
    [[`operator|`][__bitorable`<T, U = T, R = T>`][-]]
    [[`operator^`][__bitxorable`<T, U = T, R = T>`][-]]
    [[`operator<<`][__left_shiftable`<T, U = T, R = T>`][-]]
    [[`operator>>`][__right_shiftable`<T, U = T, R = T>`][-]]
    [[`operator==` and `!=`][__equality_comparable`<T, U = T>`][`!=` is implemented in terms of `==`]]
    [[`operator<`, `>`, `<=`, and `>=`][__less_than_comparable`<T, U = T>`][All are implemented in terms of `<`]]
    [[`operator+=`][__add_assignable`<T, U = T>`][-]]
    [[`operator-=`][__subtract_assignable`<T, U = T>`][-]]
    [[`operator*=`][__multiply_assignable`<T, U = T>`][-]]
    [[`operator/=`][__divide_assignable`<T, U = T>`][-]]
    [[`operator%=`][__mod_assignable`<T, U = T>`][-]]
    [[`operator&=`][__bitand_assignable`<T, U = T>`][-]]
    [[`operator|=`][__bitor_assignable`<T, U = T>`][-]]
    [[`operator^=`][__bitxor_assignable`<T, U = T>`][-]]
    [[`operator<<=`][__left_shift_assignable`<T, U = T>`][-]]
    [[`operator>>=`][__right_shift_assignable`<T, U = T>`][-]]
    [[`operator<<`][__ostreamable`<Os = std::ostream, T = _self>`][-]]
    [[`operator>>`][__istreamable`<Is = std::istream, T = _self>`][-]]
]

[table:misc Miscellaneous Operators
    [[operator][concept][notes]]
    [[`operator()`][__callable`<Sig, T>`][`Sig` should be a function type. T may be const qualified.]]
    [[`operator[]`][__subscriptable`<R, T, N = std::ptrdiff_t>`][`R` should usually be a reference. `T` can be optionally const qualified.]]
]

[table:iterator Iterator Concepts
    [[concept][notes]]
    [[__iterator`<Traversal, T, Reference, Difference>`][Use __same_type to control the iterator's value type.]]
    [[__forward_iterator`<T, Reference, Difference>`][-]]
    [[__bidirectional_iterator`<T, Reference, Difference>`][-]]
    [[__random_access_iterator`<T, Reference, Difference>`][-]]
]

[table:special Special Concepts
    [[concept][notes]]
    [[__same_type`<T>`][Indicates that two types are the same.]]
]

[endsect]

[xinclude reference.xml]

[section:rationale Rationale]

[section Why do I have to specify the presence of a destructor explicitly?]
When using references the destructor isn't needed.
By not assuming it implicitly, we allow capturing
types with private or protected destructors by reference.
For the sake of consistency, it must be specified
when capturing by value as well.
[endsect]

[section Why non-member functions?]
The members of __any can be customized.  By using
free functions, we guarantee that we don't interfere
with anything that a user might want.
[endsect]

[endsect]

[section:design Design Notes]

This section is purely for informational
purposes.  You don't need to read it to
understand how to use the library.  Here,
I try to explain how the library evolved
and why I chose the current interfaces.

[section:concepts Concept Interfaces]

When designing the concept system, I had a couple
of goals.  First of all, the basic definitions
need to be simple.  Second, concepts need to be
composable.  Making concepts composable is fairly
easy by recursively expanding mpl sequences.
The first goal is much harder.  In earlier
versions of TypeErasure and in most similar libraries
such as DynamicAny and Adobe::Poly, the base
definitions generally resemble the following

  struct incrementable_interface {
    virtual void increment() = 0;
  };
  template<class T>
  struct incrementable_implementation : incrementable_interface {
    virtual void increment() { ++x; }
    T x;
  };

  template<class Derived>
  struct incrementable_mixin {
    Derived& operater++();
  };

Note that we require three definitions, the
virtual interface, the virtual implementation,
and the user level interface.  In the immediate
predecessor of this library, the first two
were combined into a single template

  template<class T>
  struct incrementable :
    primitive_concept<incrementable<T>, void(T&) > {
    static void apply(T& t) { ++t; }
  };

Here, the `primitive_concept` base specifies the
function signature, serving the purpose of the
virtual interface.  We now have only one class
here, but it's still excessively complicated.
To get rid of this we can note that the signature
must be `remove_pointer<decltype(&incrementable<T>::apply)>::type`
and can therefore be deduced automatically.

[endsect]

[section:constructors Constructors]

The constructors of __any have to serve three
different purposes.  First, we have constructors
that capture the type passed.  This is what
happens when constructing an __any from an
`int` for example.  The second kind of constructor
dispatches to a constructor of the contained
type using an existing set of bindings.  This
is what happens for the copy constructor.  The
last kind of constructor "upcasts" from one
concept to another more general
concept.  For example, `any< mpl::vector<copy_constructible<>, incrementable<> > >`
should be convertible to `any<copy_constructible<> >`.
We want to define these three kinds of constructors
in an unambiguous way.  For short, we'll refer
to these three kinds of constructors an binding
constructors, dispatched constructors, and
converting constructors.

# binding constructors take an argument
  which is the object to capture and
  an optional argument specifying any
  bindings that can't be deduced.
# dispatched constructors take the
  arguments of the underlying constructor
  and an optional argument specifing
  the bindings to use.  (This extra
  argument is needed when the bindings
  can't be deduced because none of
  the arguments is an any.)
# converting constructors take an
  argument which must be an __any
  and an optional argument indicating
  how placeholders should be substituted.

Now, where are the ambiguities?

* A single argument which is not an __any
  can only match a binding constructor.
  It cannot match a dispatching constructor
  because we don't have anything to dispatch on.
  It can't match a converting constructor
  because it isn't an __any.
* A single argument which is an __any can
  match all three. We'll rule out binding
  constructors by arbitrarily deciding that
  an __any can never contain another __any.
  This makes our job a lot easier.  This
  leaves us with dispatched constructors
  vs. converting constructors.  If the
  Concept of the argument is different
  from the Concept of the type being
  constructed, we have to have a converting
  constructor.  If the concepts are the
  same and the placeholders are the same,
  then we have the copy constructor, and
  there is no difference between the
  dispatched constructor and the converting
  constructor.  If the placeholders are
  different, then we call the dispatched
  constructor.  In theory it's possible
  that this is intended to be converting constructor,
  but this is rare.
* For two arguments, the converting and binding
  constructors take one argument that is either
  a __binding or a __static_binding.  They
  can be distinguised by whether the other
  argument is an __any or not.

We'll add one more requirement to avoid
going crazy.  No argument of a constructor
to __any shall be __binding or __static_binding,
except for the ones that are explicitly
allowed.

Now, we can at least allow users to explicily
avoid any ambiguity with the following rules.

# If there are exactly two arguments and the
  first argument is neither an __any nor a specialization
  of __binding or __static_binding, and the second
  argement is a specialization of __binding
  or __static_binding, then this is a binding
  constructor.
# If the first argument is a specialization
  of __binding, then this is a dispatching
  constructor.
# If there are exactly two arguments and the
  first argument is an __any and the second
  argument is a specialization of __binding
  or __static_binding, the constructor is
  a converting constructor.

These are not ambiguous and any constructor
call can be converted to one of these forms.
Note in particular that the order of the
arguments is important.  If the *first*
argument is a __binding, then we have a
dispatched constructor.  If the *second*
argument is a __binding or a __static_binding,
then we have either a binding constructor or
a converting constructor.

[endsect]

[section:binding Binding]

The easiest implementation of manual type erasure
uses virtual functions.  However, virtual functions
are somewhat limited.  We get a lot more flexibility
by using explicit tables of function pointers.

* A table can be constructed dynamically.  This
  allows us to implement conversions by creating
  a subset of the table.
* A table is easy to share between multiple types.
  This makes it easier to implement multi-type concepts
  and __any references.
* A table can be passed around without a corresponding
  object.  This allows us to implement captured constructor
  calls that don't take an __any argument.

[endsect]

[section:placeholder Placeholder Names]

An earlier version of the library used the names `_1`, `_2`, etc.
instead of `_a`, `_b`, etc.  This caused a certain amount
of confusion because the numbered placeholders are
already used by several other libraries including
Boost/Std Bind, Boost.Phoenix, and Boost.MPL.  I
eventually decided that since the placeholders represented
named parameters instead of positional parameters,
letters were more appropriate than numbers.

[endsect]

[endsect]

[section:feedback Feedback Wanted]

There are a number of things that I'm not entirely
happy about.  Any thoughts about them would be
greatly appreciated.

* The name `_self`.  Basically, I need some placeholder
  to act as a default.  Since placeholders act as a
  substitute for template parameters, I'd really like
  to use `_T`.  Alack-a-day, `_T` is a reserved identifier.
  `_self` was the best I could think of.
* Implicit conversions.  Implicit conversion from the
  contained type to a reference any is not allowed.
  The reason for this is that I found that such
  conversions were interefering with overload resolution.
  Getting overload resolution to work correctly in
  the following would be a lot more difficult if
  implicit conversion were allowed:
  ``
    typedef mpl::vector<
        copy_constructible<>,
        constructible<_self(const std::string&)>
    > concept;
    any<concept> x = ...;
    any<concept> y(binding_of(x), "hello");
  ``
  Without great care we end up with an ambiguity
  between the `std::string` constructor and the
  copy constructor.  User-defined overloaded
  functions would also need to handle this somehow.
  I decided that it was better to avoid the whole
  problem by disabling implicit conversions.
* __relaxed_match.  I considered a lot of names
  for this, `strict_match<false>`, `enable_mixed`,
  `nonstrict_match`, `loose_match`, `best_effort`,
  and probably more that I've forgotten.  I'm not
  really happy with any of them.  I'm not really
  happy about having it in `Concept` either, but
  I'm not sure where else it could go.  It's presence
  can affect the contents of the vtable, so if it
  were a separate template argument, it would have
  to be passed to __binding as well.  It would generally
  add complication.

[endsect]

[section:future Future Work]

These are just some ideas.  There is absolutely no
guarantee that any of them will ever be implemented.

* Use SBO.
* Allow more control over vtable layout.
* Attempt to reuse sub-tables in conversions.
* Allow "dynamic_cast".
* Use C++0x features.  (Rvalue references and
  variadic templates in particular.)
* Optimize the compile-time cost.

[endsect]


[section:acknowledgements Acknowledgements]

* The name `any` was taken from Alexander Nasonov's
  DynamicAny library.

[endsect]
